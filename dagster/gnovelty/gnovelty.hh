/**********************************************************/
/* A gradient based Novelty+ for guiding a Conflict       */
/* Driven Clause Learning procedure. This module is       */
/* based on gNovelty+, version 1.0                        */
/*                                                        */
/*   Authors in chronological order                       */
/*                                                        */
/*      1. Charles Gretton (charles.gretton@anu.edu.au)   */ 
/*            Australian National University              */
/*                                                        */
/*      2. Josh Milthorpe (josh.milthorpe@anu.edu.au)     */ 
/*            Australian National University              */
/*                                                        */
/*      3. Tate Kennington (tatekennington@gmail.com)     */ 
/*            University of Dunedin, New Zealand          */
/*            ANU Summer Scholarship 2018/19              */
/*                                                        */
/*      4. Mark Burgess  (markburgess1989@gmail.com)      */ 
/*            Australian National University              */
/*            Research Assistant 2019/20                  */
/*                                                        */
/*                                                        */
/**********************************************************/
/* Based on -- gNovelty+, version 1.0                     */
/*                                                        */
/*      A greedy gradient based Novelty+                  */
/*                                                        */
/*      1. Duc Nghia Pham (duc-nghia.pham@nicta.com.au)   */ 
/*            SAFE Program,  National ICT Australia Ltd.  */
/*            IIIS, Griffith University, Australi         */
/*                                                        */
/*      2. Charles Gretton (charles.gretton@gmail.com)    */ 
/*            University of Birmingham                    */
/*            IIIS, Griffith University, Australia        */
/*                                                        */
/*                                                        */
/**********************************************************/
/* Part of gNovelty+ is based on UBCSAT version 1.0       */
/* written by:                                            */
/* Dave A.D. Tompkins & Holger H. Hoos                    */
/*   Univeristy of British Columbia                       */
/* February 2004                                          */
/**********************************************************/

/*************************
This file is part of Dagster.

Dagster is free software; you can redistribute it 
and/or modify it under the terms of the GNU General 
Public License as published by the Free Software 
Foundation; either version 2 of the License, or
(at your option) any later version.

Dagster is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR 
A PARTICULAR PURPOSE. See the GNU General Public 
License for more details.

You should have received a copy of the GNU General 
Public License along with Dagster.
If not, see <http://www.gnu.org/licenses/>.
*************************/

#ifndef __GNOVELTY_H__
#define __GNOVELTY_H__

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <vector>
#include <set>
#include <cstring>

#define CWTYPE int
//#define CWTYPE double
#define NOVALUE -1

// Basic variables and data structures
#include "../Cnf.h"
#include "State.h"
#include "ReversableIntegerMap.h"
#include <glog/logging.h>
#include "../RangeSet.h"



  // A "ghost" suggestion (i.e. a recent assignment made by the
  // local search), is an assignment to a variable that was/is
  // recently consistent with the \member{state} currently being
  // pursued by the local search. When the search reaches a
  // local minima, there is a chance that assignments here are
  // inconsistent. These are just written in round robin fashion
  // to a fixed size data structure.

class Gnovelty {
protected:
  Cnf* cnf; // the CNF data structure
  int noise;// = 50;		// default noise (in percent)

  //=== data structures which will actively change with flips/prefix changes
  bool* inPrefix;						// an array of bools keeping track of what variables are specified by the prefix or not, generated by loadPrefix()
  CWTYPE* variableScore;				// the score of a variable, in the SLS routine, modified by (adjScore,incScore,decScore functions) and read in context of variable selection functions (pickVar_())
  int* variableNumScore;				// the number of net score increments/decrements of a variable, in the SLS routine, modified by (incScore,decScore functions) 
  int* varLastChange;					// for each variable, the time it was last flipped, according to the internal 'flip' counter
  int* numTrueLit;						// number of true literals in each clause

  //=== data structures specific to processSolution method
  int* numUnsetLit;						// number of unset literals in each clause (only used in processSolution method)
  bool* solutionClauses;				// a series of flags indicating whether a clause has been added only to drive gnovelty away from previous answers (influences overlap in processSolution method)
  int solution_style;					// flag indicating how processSolution gives solutions:
										//  0 = solutions where all variables are assigned
										//  1 = solutions with some variables unassigned, but solutions do not overlap
										//  2 = solutions with some variables unassigned, and solutions do overlap

  inline void set_inPrefix_TRUE(int var);	// sets a variable to be in the prefix, respects candVar list
  inline void set_inPrefix_FALSE(int var);	// sets a variable to be not in the prefix, respects candVar list

  //=== Data structures to support _ghosts_ suggestion offerings
  //    a mechanism to communicate recent SLS decisions to the CDCL procedure
  int _ghost__suggestion_index;
  int* _ghost__suggestions;
  int _ghost__suggestion_buffer_size;

  //=== AdaptNovelty+ controlled variables
  int lastAdaptFlip;
  int lastAdaptNumFalse;
  int invPhi;
  int invTheta;

  //== functions which determine and adapt the variableScores of the variables
  void setupScores();
  inline void adjScore(int var, int val); // set the clause to have a score increment of val
  inline void incScore(int var, int cls); // increase the score of var by the clause weight of clause cls
  inline void decScore(int var, int cls); // decrease the score of var by the clause weight of clause cls

  int pickVar_greedy(); // returns the variable to flip according to the 'greedy' steepest decent of satisfying clauses with the most negative score less than zero
  int pickVar_normal(); // returns the variable to flip according to the 'normal' algorithm with the most lowest score, stochastically switching to second lowest score
  int pickVar_random(); // returns the variable to flip according to random variable form a random clause
  void flipAtom(int toflip); // flips a variable and updates all data structures accordingly
  void purge_candVar(); // the candVar array stores elements with score < 0 , needs to be purged of variables which now have score > 0
  void reset_candVar(); // resets the candVar array to thoes elements with score < 0 and are not in the prefix
  virtual void updateClauseWeights()=0;
  void adaptNoveltyNoise(); // applies AdaptNovelty+ logic
  
  CWTYPE* clauseWeight;// weight of a clause
  ReversableIntegerMap* falseClauses; // clauses that are false:
  ReversableIntegerMap* candVar;		// an list that (sort of....) keeps variables which have wieght less than zero and are not in the prefix
  int* isCandVar;

public:
  long int flip;  // counter for flips
  virtual ~Gnovelty(){
    delete state;
    delete falseClauses;
    delete candVar;
    free(clauseWeight);
    free(solutionClauses);
    free(numTrueLit);
    free(numUnsetLit);
    free(variableScore);
    free(variableNumScore);
    free(varLastChange);
    free(inPrefix);
    free(isCandVar);
    free(_ghost__suggestions);
  }
  Gnovelty(Cnf* new_Cnf, int noise, int _ghost__suggestion_buffer_size);
  Gnovelty(Cnf* new_Cnf, int noise, int _ghost__suggestion_buffer_size, int solution_style);
  State* state;

  void loadSuggestion(int* suggestions, int suggestion_size);
  void loadSuggestion_ghost(int* suggestions, int suggestion_size);
  int loadPrefix(int* prefix, int prefixLength);
  virtual void addClause(int* clause);
  int* processSolution();
  int* processSolution(vector<int> &variables);
  int* processSolution(set<int> &variables);
  int* processSolution(RangeSet &variables);

  int step(int walkProb, bool adaptFlag);
  int step_newStyle(int walkProb, bool adaptFlag);
};



// A GNovelty variant where there is no clause weight updates
class Gnovelty_updateClauseWeights_NULL : public Gnovelty {
public:
  void updateClauseWeights() {};
  Gnovelty_updateClauseWeights_NULL(Cnf* new_Cnf, int noise, int _ghost__suggestion_buffer_size)
   : Gnovelty(new_Cnf, noise, _ghost__suggestion_buffer_size) {}

  Gnovelty_updateClauseWeights_NULL(Cnf* new_Cnf, int noise, int _ghost__suggestion_buffer_size, int solution_style)
   : Gnovelty_updateClauseWeights_NULL(new_Cnf,noise,_ghost__suggestion_buffer_size) {
    this->solution_style = solution_style;
  }
};

// a Gnnovelty variant which uses linear clause weighting
class Gnovelty_updateClauseWeights_Linear : public Gnovelty {
public:
  ~Gnovelty_updateClauseWeights_Linear() {
    delete weightedClauses;
  }
  Gnovelty_updateClauseWeights_Linear(Cnf* new_Cnf, int noise, int _ghost__suggestion_buffer_size, int smoothProb) 
    : Gnovelty(new_Cnf, noise, _ghost__suggestion_buffer_size) {
    this->smoothProb = smoothProb;
    weightedClauses = new ReversableIntegerMap(new_Cnf->cc);
  }
  Gnovelty_updateClauseWeights_Linear(Cnf* new_Cnf, int noise, int _ghost__suggestion_buffer_size, int smoothProb, int solution_style)
   : Gnovelty_updateClauseWeights_Linear(new_Cnf,noise,_ghost__suggestion_buffer_size,smoothProb) {
    this->solution_style = solution_style;
  }
  void addClause(int* clause) override;
  void updateClauseWeights() override;
  ReversableIntegerMap* weightedClauses;
  int smoothProb;
  void smooth();
};

/*
// a Gnovelty variant that uses exponential clause weighting
// NOTE: must set CWTYPE to double for this to make sense.
class Gnovelty_updateClauseWeights_Exp : Gnovelty {
public:
  ~Gnovelty_updateClauseWeights_Exp() {
    free(trace);
    free(stepSize);
  }
  Gnovelty_updateClauseWeights_Exp(Cnf* new_Cnf, bool using__ghost_suggestions, int noise, int _ghost__suggestion_buffer_size) 
    : Gnovelty(new_Cnf, using__ghost_suggestions, noise, _ghost__suggestion_buffer_size) {
    trace = (CWTYPE*)calloc(sizeof(CWTYPE),cnf->cc);
    stepSize = (CWTYPE*)calloc(sizeof(CWTYPE),cnf->cc);
    // required for the stepsize weighting
    pseudoStepSize = pow(10.0, -15);
    traceDiscount = 0.99;
    for (i = 0; i < cnf->cc; i++) {
        trace[i] = 0.0;
        stepSize[i] = pseudoStepSize;
    }
  }
  inline double _EXP(double X) {return max(0.001, 1.0 + (X));} //Fake update that is faster than machine exponent.
  void updateClauseWeights();
  CWTYPE pseudoStepSize;
  CWTYPE traceDiscount;
  CWTYPE* trace;
  CWTYPE* stepSize;
};
*/
#endif

