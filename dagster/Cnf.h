/*************************
Copyright 2020 Mark Burgess

This file is part of Dagster.

Dagster is free software; you can redistribute it 
and/or modify it under the terms of the GNU General 
Public License as published by the Free Software 
Foundation; either version 2 of the License, or
(at your option) any later version.

Dagster is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR 
A PARTICULAR PURPOSE. See the GNU General Public 
License for more details.

You should have received a copy of the GNU General 
Public License along with Dagster.
If not, see <http://www.gnu.org/licenses/>.
*************************/
//
//Originally extending from Tinisat
// undder GPL, authored 2007 Jinbo Huang
//

#ifndef _CNF
#define _CNF

#include <vector>
#include "RangeSet.h"
using namespace std;

class Cnf {
public:
  unsigned vc;	// var count
  unsigned cc;	// clause count
  int **clauses;	// 2-dim. array with entries same as in cnf file
  unsigned *cl;	// clause length
  bool dereferenced;

  Cnf();
  Cnf(const char *fname);
  Cnf(const char *fname, const vector<int> &indices);
  Cnf(const char *fname, RangeSet &set_indices);
  Cnf(Cnf* cnf, RangeSet &set_indices);
  ~Cnf();
  Cnf(Cnf* cnf);
  Cnf(int** new_data);
  Cnf(int** new_data, bool dereferenced);
  Cnf(int* dehydrated_data);

  void output_dimacs(const char *fname); // outputs the CNF to a file
  void output_dimacs(FILE* fp); // outputs the CNF to a file
  void print(); // printf the CNF

  void load_DIMACS_Cnf(FILE* ifp);
  void load_DIMACS_Cnf(FILE* ifp, const vector<int> &indices);
  void load_DIMACS_Cnf(FILE* ifp, RangeSet &set_indices);

  void load_DIMACS_Cnf(const char* fname);
  void load_DIMACS_Cnf(const char* fname, const vector<int> &indices);
  void load_DIMACS_Cnf(const char* fname, RangeSet &set_indices);

  void add_unitary_clause(int unit); // add a unitary clause into the CNF (note, destroys occurence and neighborhood info)
  void add_clause(int* clause); // add a clause into the CNF (note, destroys occurence and neighborhood info)
  void join(Cnf* c);  // join another CNF to this one (note, destroys occurence and neighborhood info)

  //=== data structures holding information about CNF which is loaded in (these can be NULL)
  int** occurence;		// where each literal occurs: indexed as occurence[literal+MAXATOM][occurence_num], generated by compute_occurance_buffers()
  int* numOccurence;	// number of times each literal occurs, generated by compute_occurance_buffers()
  int** neighbourVar;   // stores the neighborhood of variables in clauses around a specific variable.
  void compute_occurance_buffers();
  void compute_variable_neighborhoods();
  void compute_variable_neighborhoods__DEPRECATED();
  void compute_variable_neighborhoods__DEPRECATED_2();

  int dehydrate(int *output_data);     // turn the clauses into a newly created series of ints
  int get_dehydrated_size();  // returns the size of the dehydrated string (int ints)

private:
  void populate_from_clauses();
  void free_occurence_and_neighborhood_buffers();
  void hydrate(int* input_data); // turn a series of ints into a coherent set of clauses
};
#endif
